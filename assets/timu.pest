file                        = _{ SOI ~ module* ~ EOI }
input                       = _{ SOI ~ body_expression+ ~ EOI }

WHITESPACE                  = _{ WHITE_SPACE }
COMMENT                     = _{ comment_block | comment_line }
comment_block               = @{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }
comment_line                = @{ "//" ~ (!("\r" | "\n") ~ ANY)* }
documentation               = ${ "/*doc" ~ documentation_content ~ "*/"}
documentation_content       =  { (!"*/" ~ ANY)* }

import                      =  { "@use" ~ "(" ~ importproperties ~ ")" ~ ("as" ~ importname)? ~ ";" }
importproperties            =  { importproperty ~ ("." ~ importproperty)* }
importproperty              =  { typename_name }
importname                  =  { typename_name }

module                      = _{ import | documentation | deffunc | defvariable }

typeunion                   =  { typename ~ (plus ~ typename)+ }
typeblock                   =  { "{" ~ typeblockcontents* ~ "}" }
typeblockcontents           = _{ documentation | deffunc }

deffunc                     =  { "func" ~ ident ~ deffuncarguments ~ maybe_type_annotation ~ body_block }
deffuncarguments            =  { ( "(" ~ (deffuncargument ~ ("," ~ deffuncargument)*)? ~ ")" )? }
deffuncargument             =  { keyword ~ typename }

body_block                  =  { "{" ~ body_expression* ~ "}" }
body_expression             = _{ defvariable | assignvariable | (expression ~ ";") }

expression                  = _{ infix | expression_inner }
call_remote                 =  { typename ~ "." ~ ident ~ "(" ~ call_args ~ ")" }
func_call                   =  { local ~ "(" ~ call_args ~ ")" }
index                       =  { (local | literal | braced_expression) ~ "." ~ ident }
infix                       = _{ expression_inner ~ binary_operator ~ expression_inner }
expression_inner            = _{ call_remote | func_call | index | unary | literal | defvariable_name | local | braced_expression }
call_args                   = _{ (expression ~ ("," ~ expression)*)? }
braced_expression           = _{ "(" ~ expression ~ ")" }
defvariable                 =  { var_type ~ defvariable_name ~ maybe_type_annotation ~ "=" ~ expression ~ ";" }
defvariable_name            =  { "$" ~ ident }
assignvariable              =  { defvariable_name ~ "=" ~ expression ~ ";" }
unary                       =  { unary_operator ~ (literal | defvariable_name | braced_expression) }
literal                     = _{ string | boolean | float | integer | string }

ident                       = @{ ("_" | LETTER) ~ (LETTER | NUMBER | "_")* ~ ("?")? }
keyword                     = ${ ident ~ ":" }
maybe_type_annotation       =  { ( ":" ~ typename )? }

local                       =  { ident }

typename                    = _{ typename_name ~ ("." ~ typename_name)* }
typename_name               = @{ "_"* ~ LETTER ~ (LETTER | NUMBER | "_")* }

float                       = ${ float_characteristic ~ "." ~ float_mantissa }
float_characteristic        =  { "0" | (('1'..'9') ~ ('0'..'9' | "_")*) }
float_mantissa              =  { ('0'..'9')+ }

integer                     = ${ integer_hexadecimal_sigil | integer_octal_sigil | integer_binary_sigil | integer_decimal | integer_zero }
integer_decimal             =  { '1'..'9' ~ ('0'..'9' | "_")* }
integer_hexadecimal         =  { ('0'..'9' | 'a'..'f' | 'A'..'F') ~ ('0'..'9' | 'a'..'f' | 'A'..'F' | "_")* }
integer_hexadecimal_sigil   = _{ "0x" ~ integer_hexadecimal }
integer_octal               =  { ('0'..'7') ~ ('0'..'7' | "_" )* }
integer_octal_sigil         = _{ "0o" ~ integer_octal }
integer_binary              =  { ('0'..'1') ~ ('0'..'1' | "_")* }
integer_binary_sigil        = _{ "0b" ~ integer_binary }
integer_zero                =  { "0" }

string                      = ${ string_single_line }
string_single_line          = _{ string_delimiter ~ string_content ~ string_delimiter }
string_content              = ${ (string_escape | string_unicode | string_simple)* }
string_delimiter            = _{ "\"" }
string_simple               = ${ (!(string_delimiter | "\\") ~ ANY)+ }
string_unicode              = ${ "\\u" ~ ('0'..'9' | 'a'..'f' | 'A'..'F'){4} }
string_escape               = ${ "\\" ~ ("\"" | "\\" | "a" | "b" | "f" | "n" | "r" | "t" | "v") }

at                          =  { "@" }
exponent                    =  { "**" }
multiply                    =  { "mul" }
divide                      =  { "div" }
modulo                      =  { "mod" }
plus                        =  { "sum" }
minus                       =  { "sub" }
shift_left                  =  { "lshift" }
shift_right                 =  { "rshift" }
less_than                   =  { "less" }
less_than_or_equal          =  { "eless" }
greater_than                =  { "bigger" }
greater_than_or_equal       =  { "ebigger" }
not_equal                   =  { "neq" }
equal                       =  { "eq" }
logical_and                 =  { "and" }
logical_or                  =  { "or" }
logical_not                 =  { "not" }
bitwise_and                 =  { "band" }
bitwise_or                  =  { "bor" }
bitwise_xor                 =  { "xor" }
all_operators               = _{
                                 exponent |
                                 multiply | divide | modulo |
                                 plus | minus |
                                 shift_left | shift_right |
                                 less_than_or_equal | less_than |
                                 greater_than_or_equal | greater_than |
                                 not_equal | equal |
                                 logical_and | logical_or | logical_not |
                                 bitwise_and | bitwise_or | bitwise_xor
                                }
binary_operator             = _{
                                 exponent |
                                 multiply | divide | modulo |
                                 plus | minus |
                                 shift_left | shift_right |
                                 less_than_or_equal | less_than |
                                 greater_than_or_equal | greater_than |
                                 not_equal | equal |
                                 logical_and | logical_or |
                                 bitwise_and | bitwise_or | bitwise_xor
                               }
unary_operator              = _{ plus | minus | logical_not }

boolean                     =  { boolean_true | boolean_false }
boolean_true                =  { "true" }
boolean_false               =  { "false" }


var_type                    = { "var" | "const" }