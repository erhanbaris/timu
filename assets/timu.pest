file                        = _{ SOI ~ module* ~ EOI }
input                       = _{ SOI ~ body_expression+ ~ EOI }

WHITESPACE                  = _{ WHITE_SPACE }
COMMENT                     = _{ comment_block | comment_line }
comment_block               = @{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }
comment_line                = @{ "//" ~ (!("\r" | "\n") ~ ANY)* }
documentation               = ${ "/*doc" ~ documentation_content ~ "*/"}
documentation_content       =  { (!"*/" ~ ANY)* }

import                      =  { "@use" ~ "(" ~ importproperties ~ ")" ~ ("as" ~ importname)? ~ ";" }
importproperties            =  { importproperty ~ ("." ~ importproperty)* }
importproperty              =  { typename_name }
importname                  =  { typename_name }

module                      = _{ import | documentation | defclass | def }

defclass                    =  { "class" ~ typename ~ defclassfields? ~ defclassproperties }
defclassfields             =  { ("(" ~ (defclassfield  ~ ("," ~ defclassfield)*)? ~ ")")? }
defclassfield              =  { keyword ~ (typeunion | typename) }
defclassproperties         =  { ("," ~ defclassproperty)* }
defclassproperty           =  { keyword ~ (typeblock | typeunion | typename) }

defprotocol                 =  { "protocol" ~ typename ~ defprotocolproperties }
defprotocolproperties       =  { ("," ~ defprotocolproperty)* }
defprotocolproperty         =  { keyword ~ (typeblock | typeunion | typename) }

defimpl                     =  { "impl" ~ typename ~ defimplproperties }
defimplproperties           =  { ("," ~ defimplproperty)* }
defimplproperty             =  { keyword ~ (typeblock | typeunion | typename) }

defuse                      =  { "use" ~ typename ~ defuseproperties }
defuseproperties            =  { ("," ~ defuseproperty)* }
defuseproperty              =  { keyword ~ typename }

typeunion                   =  { typename ~ (plus ~ typename)+ }
typeblock                   =  { "{" ~ typeblockcontents* ~ "}" }
typeblockcontents           = _{ documentation | def }

def                         =  { "func" ~ ident ~ defarguments ~ maybe_type_annotation ~ body_block }
defarguments                =  { ( "(" ~ (defargument ~ ("," ~ defargument)*)? ~ ")" )? }
defargument                 =  { keyword ~ typename }
defproperties               =  { ("," ~ defproperty)* }
defproperty                 =  { keyword ~ (body_block | body_expression) }

body_block                  =  { "{" ~ body_expression* ~ "}" }
body_expression             = _{ let_binding | expression }

expression                  = _{ infix | expression_inner }
call_remote                 =  { typename ~ "." ~ ident ~ "(" ~ call_args ~ ")" }
call_local                  =  { local ~ "(" ~ call_args ~ ")" }
index                       =  { (local | literal | braced_expression) ~ "." ~ ident }
infix                       =  { expression_inner ~ (binary_operator ~ expression_inner)+ }
expression_inner            = _{ call_remote | call_local | index | unary | literal | local | braced_expression }
call_args                   = _{ (expression ~ ("," ~ expression)*)? }
braced_expression           = _{ "(" ~ expression ~ ")" }
let_binding                 =  { "let" ~ ident ~ maybe_type_annotation ~ "=" ~ expression }
unary                       =  { unary_operator ~ (literal | local | braced_expression) }
literal                     = _{ string | atom | boolean | float | integer | string | array | map | constructor }

ident                       = @{ ("_" | LOWERCASE_LETTER) ~ (LETTER | NUMBER | "_")* ~ ("?")? }
keyword                     = ${ ident ~ ":" }
maybe_type_annotation       =  { ( ":" ~ typename )? }

constructor                 =  { constructor_prefix ~ (constructor_property ~ ("," ~ constructor_property)*)? ~ "}" }
constructor_prefix          = _{ typename ~ "{" }
constructor_property        =  { keyword ~ expression }

map                         =  { "{" ~ (map_pair ~ ("," ~ map_pair)*)? ~ "}" }
map_pair                    =  { (keyword | (expression ~ "=>")) ~ expression }

array                       =  { "[" ~ (expression ~ ("," ~ expression)*)? ~ "]" }

atom                        = @{ ":" ~ atom_ident }
atom_ident                  = ${ LETTER ~ (LETTER | NUMBER | "_")* }
local                       =  { ident }

typename                    = _{ typename_name ~ ("." ~ typename_name)* }
typename_name               = @{ "_"* ~ LETTER ~ (LETTER | NUMBER | "_")* }

float                       = ${ float_characteristic ~ "." ~ float_mantissa }
float_characteristic        =  { "0" | (('1'..'9') ~ ('0'..'9' | "_")*) }
float_mantissa              =  { ('0'..'9')+ }

integer                     = ${ integer_hexadecimal_sigil | integer_octal_sigil | integer_binary_sigil | integer_decimal | integer_zero }
integer_decimal             =  { '1'..'9' ~ ('0'..'9' | "_")* }
integer_hexadecimal         =  { ('0'..'9' | 'a'..'f' | 'A'..'F') ~ ('0'..'9' | 'a'..'f' | 'A'..'F' | "_")* }
integer_hexadecimal_sigil   = _{ "0x" ~ integer_hexadecimal }
integer_octal               =  { ('0'..'7') ~ ('0'..'7' | "_" )* }
integer_octal_sigil         = _{ "0o" ~ integer_octal }
integer_binary              =  { ('0'..'1') ~ ('0'..'1' | "_")* }
integer_binary_sigil        = _{ "0b" ~ integer_binary }
integer_zero                =  { "0" }

string                      = ${ string_single_line }
string_single_line          = _{ string_delimiter ~ string_content ~ string_delimiter }
string_content              = ${ (string_escape | string_unicode | string_simple)* }
string_delimiter            = _{ "\"" }
string_simple               = ${ (!(string_delimiter | "\\") ~ ANY)+ }
string_unicode              = ${ "\\u" ~ ('0'..'9' | 'a'..'f' | 'A'..'F'){4} }
string_escape               = ${ "\\" ~ ("\"" | "\\" | "a" | "b" | "f" | "n" | "r" | "t" | "v") }

at                          =  { "@" }
exponent                    =  { "**" }
multiply                    =  { "*" }
divide                      =  { "/" }
modulo                      =  { "%" }
plus                        =  { "+" }
minus                       =  { "-" }
shift_left                  =  { "<<" }
shift_right                 =  { ">>" }
less_than                   =  { "<" }
less_than_or_equal          =  { "<=" }
greater_than                =  { ">" }
greater_than_or_equal       =  { ">=" }
not_equal                   =  { "!=" }
equal                       =  { "==" }
logical_and                 =  { "&&" }
logical_or                  =  { "||" }
logical_not                 =  { "!" }
bitwise_and                 =  { "&" }
bitwise_or                  =  { "|" }
bitwise_xor                 =  { "^" }
all_operators               = _{
                                 exponent |
                                 multiply | divide | modulo |
                                 plus | minus |
                                 shift_left | shift_right |
                                 less_than_or_equal | less_than |
                                 greater_than_or_equal | greater_than |
                                 not_equal | equal |
                                 logical_and | logical_or | logical_not |
                                 bitwise_and | bitwise_or | bitwise_xor
                                }
binary_operator             = _{
                                 exponent |
                                 multiply | divide | modulo |
                                 plus | minus |
                                 shift_left | shift_right |
                                 less_than_or_equal | less_than |
                                 greater_than_or_equal | greater_than |
                                 not_equal | equal |
                                 logical_and | logical_or |
                                 bitwise_and | bitwise_or | bitwise_xor
                               }
unary_operator              = _{ plus | minus | logical_not }

boolean                     =  { boolean_true | boolean_false }
boolean_true                =  { "true" }
boolean_false               =  { "false" }

