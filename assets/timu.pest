file                        = _{ SOI ~ module* ~ EOI }
input                       = _{ SOI ~ body_expression+ ~ EOI }

WHITESPACE                  = _{ WHITE_SPACE }
COMMENT                     = _{ comment_block | comment_line }
comment_block               = @{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }
comment_line                = @{ "//" ~ (!("\r" | "\n") ~ ANY)* }
documentation               = ${ "/*doc" ~ documentation_content ~ "*/"}
documentation_content       =  { (!"*/" ~ ANY)* }

import                      =  { at ~ "use" ~ "(" ~ import_properties ~ ")" ~ ("as" ~ import_name)? ~ ";" }
import_properties           =  { import_property ~ ("." ~ import_property)* }
import_property             =  { typename_name | "*" }
import_name                 =  { typename_name }

module                      = _{ import | documentation | define_function | define_type | define_variable }

define_function             =  { pub_visibility? ~ "func" ~ ident ~ define_function_arguments ~ define_function_return_type ~ body_block }
define_function_return_type =  { type_annotation }
define_function_arguments   =  { ( "(" ~ (define_function_argument ~ ("," ~ define_function_argument)*)? ~ ")" )? }
define_function_argument    =  { keyword ~ typename }

define_type                 =  { "type" ~ ident ~ "{" ~ define_type_fields ~ "}" }
define_type_field           =  { pub_visibility? ~ define_variable_name ~ ":" ~ nullable? ~ typename }
define_type_fields          =  { (define_function | define_type_field) ~ ("," ~ (define_function | define_type_field))* }

body_block                  =  { "{" ~ body_expression* ~ "}" }
body_expression             = _{ define_variable | assign_variable | (expression ~ ";") }

expression                  = _{ infix | expression_inner }
call_remote                 =  { typename ~ "." ~ ident ~ "(" ~ call_args ~ ")" }
function_call               =  { local ~ "(" ~ call_args ~ ")" }
index                       =  { (local | literal | braced_expression) ~ "." ~ ident }
infix                       = _{ expression_inner ~ binary_operator ~ expression_inner }
expression_inner            = _{ call_remote | function_call | index | unary | literal | define_variable_name | local | braced_expression }
call_args                   = _{ (expression ~ ("," ~ expression)*)? }
braced_expression           = _{ "(" ~ expression ~ ")" }
define_variable             =  { meta? ~ static? ~ var_type? ~ define_variable_name ~ maybe_type_annotation ~ "=" ~ expression ~ ";" }
define_variable_name        =  { ident }
assign_variable             =  { define_variable_name ~ "=" ~ expression ~ ";" }
unary                       =  { unary_operator ~ (literal | define_variable_name | braced_expression) }
literal                     = _{ primitive_type_string | primitive_type_boolean | primitive_type_float | primitive_type_integer | primitive_type_string }
static                      = _{ "static" }
pub_visibility              =  { "pub" }
nullable                    =  { "?" }
meta                        = _{ "@" ~ ident }

ident                       = @{ ("_" | LETTER) ~ (LETTER | NUMBER | "_")* ~ ("?")? }
keyword                     = ${ ident ~ ":" }
maybe_type_annotation       =  { ( ":" ~ typename )? }
type_annotation             = _{ ":" ~ typename }

local                       =  { ident }


typename                    = _{ typename_name ~ ("." ~ typename_name)* }
typename_name               = @{ "_"* ~ LETTER ~ (LETTER | NUMBER | "_")* }

// Primitive types
primitive_type_float        = ${ float_characteristic ~ "." ~ float_mantissa }
float_characteristic        =  { "0" | (('1'..'9') ~ ('0'..'9' | "_")*) }
float_mantissa              =  { ('0'..'9')+ }

primitive_type_integer       = ${ integer_hexadecimal_sigil | integer_octal_sigil | integer_binary_sigil | integer_decimal | integer_zero }
integer_decimal             =  { '1'..'9' ~ ('0'..'9' | "_")* }
integer_hexadecimal         =  { ('0'..'9' | 'a'..'f' | 'A'..'F') ~ ('0'..'9' | 'a'..'f' | 'A'..'F' | "_")* }
integer_hexadecimal_sigil   = _{ "0x" ~ integer_hexadecimal }
integer_octal               =  { ('0'..'7') ~ ('0'..'7' | "_" )* }
integer_octal_sigil         = _{ "0o" ~ integer_octal }
integer_binary              =  { ('0'..'1') ~ ('0'..'1' | "_")* }
integer_binary_sigil        = _{ "0b" ~ integer_binary }
integer_zero                =  { "0" }

primitive_type_string       = ${ string_single_line }
string_single_line          = _{ string_delimiter ~ string_content ~ string_delimiter }
string_content              = ${ (string_escape | string_unicode | string_simple)* }
string_delimiter            = _{ "\"" }
string_simple               = ${ (!(string_delimiter | "\\") ~ ANY)+ }
string_unicode              = ${ "\\u" ~ ('0'..'9' | 'a'..'f' | 'A'..'F'){4} }
string_escape               = ${ "\\" ~ ("\"" | "\\" | "a" | "b" | "f" | "n" | "r" | "t" | "v") }

at                          =  { "@" }
exponent                    =  { "**" }
multiply                    =  { "*" }
divide                      =  { "/" }
modulo                      =  { "%" }
plus                        =  { "+" }
minus                       =  { "-" }
shift_left                  =  { "<<" }
shift_right                 =  { ">>" }
less_than                   =  { "<" }
less_than_or_equal          =  { "<=" }
greater_than                =  { ">" }
greater_than_or_equal       =  { ">=" }
not_equal                   =  { "!=" }
equal                       =  { "==" }
logical_and                 =  { "&&" }
logical_or                  =  { "||" }
logical_not                 =  { "!" }
bitwise_and                 =  { "&" }
bitwise_or                  =  { "|" }
bitwise_xor                 =  { "^" }
all_operators               = _{
                                 exponent |
                                 multiply | divide | modulo |
                                 plus | minus |
                                 shift_left | shift_right |
                                 less_than_or_equal | less_than |
                                 greater_than_or_equal | greater_than |
                                 not_equal | equal |
                                 logical_and | logical_or | logical_not |
                                 bitwise_and | bitwise_or | bitwise_xor
                                }
binary_operator             = _{
                                 exponent |
                                 multiply | divide | modulo |
                                 plus | minus |
                                 shift_left | shift_right |
                                 less_than_or_equal | less_than |
                                 greater_than_or_equal | greater_than |
                                 not_equal | equal |
                                 logical_and | logical_or |
                                 bitwise_and | bitwise_or | bitwise_xor
                               }
unary_operator              = _{ plus | minus | logical_not }

primitive_type_boolean      =  { boolean_true | boolean_false }
boolean_true                =  { "true" }
boolean_false               =  { "false" }


var_type                    = { "var" | "const" }