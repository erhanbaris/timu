file       =  { SOI ~ (anything)* ~ EOI }
anything   = _{ import | func_def | assign_stmt }
WHITESPACE = _{ " " | "\t" | NEWLINE }

// Keywords
keyword_public   = _{ "pub" }
keyword_use      = _{ "use" }
keyword_function = _{ "fun" }
keyword_as       = _{ "as" }
keyword_true     = _{ "true" }
keyword_false    = _{ "false" }

// Symbols
symbol_none           =  { "_" }
symbol_compile_time   = _{ "@" }
symbol_assign         = _{ "=" }
symbol_line_finish    = _{ ";" }
symbol_array_start    = _{ "[" }
symbol_array_end      = _{ "]" }
symbol_parant_start   = _{ "(" }
symbol_parant_end     = _{ ")" }
symbol_term_seperator = _{ "," }
symbol_add            =  { "+" }
symbol_subtract       =  { "-" }
symbol_multiply       =  { "*" }
symbol_divide         =  { "/" }

// Compiler attribute
compiler_attr = { symbol_compile_time ~ var_name }

// Assignment
assign_name = { var_name }
assign_type = { var_type }
assign_stmt = { compiler_attr* ~ assign_name ~ symbol_assign ~ primative ~ symbol_line_finish }

// primatives
primative_string_inner =  { ("\"\"" | (!"\"" ~ ANY))* }
primative_string       = ${ "\"" ~ primative_string_inner ~ "\"" }
primative_integer      = @{ "-"? ~ ("0" | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT*) }
primative_float        = @{ primative_integer ~ ("." ~ ASCII_DIGIT*) ~ (^"e" ~ ("+" | "-")? ~ ASCII_DIGIT+)? }
primative_bool         =  { keyword_true | keyword_false }
primative_array        =  { symbol_array_start ~ (primative ~ ("," ~ primative)*)? ~ symbol_array_end }
primative              =  { primative_bool | primative_float | primative_integer | primative_string | primative_array }

binary_operator  = _{ symbol_add | symbol_subtract | symbol_multiply | symbol_divide }
atom             = _{ primative | func_call }
binary_operation =  { atom ~ (binary_operator ~ atom)+ }
expression       =  { binary_operation | atom }

// Comments
comment_multiline = @{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }
comment_line      = @{ "//" ~ (!NEWLINE ~ ANY)* ~ NEWLINE }
COMMENT           = _{ comment_multiline }

// Definitions
var_name  = @{ "_"* ~ ASCII_ALPHA+ ~ (ASCII_ALPHA+ | NUMBER+ | "_")* }
var_type  = ${ "_"* ~ ASCII_ALPHA+ ~ (ASCII_ALPHA+ | NUMBER+ | "_")* }
comp_sign = _{ "@" }

// Imports
import_name =  { var_name }
import_path = @{ ("_"* ~ ASCII_ALPHA+ ~ (ASCII_ALPHA+ | NUMBER+ | "_")*) | "*" }
import_use  = _{ comp_sign ~ keyword_use ~ "(" ~ (import_path ~ ("." ~ import_path)*) ~ ")" }
import      =  { import_use ~ (keyword_as ~ import_name)? ~ ";" }

statement  =  { assign_stmt | (func_call ~ ";") }
statements = _{ statement* }

func_name        = @{ "_"* ~ ASCII_ALPHA+ ~ (ASCII_ALPHA+ | NUMBER+ | "_")* }
func_seperator   = _{ ":" }
func_return_type =  { func_seperator ~ var_type }
func_body        =  { ("{" ~ statements? ~ "}") | (func_seperator ~ statement) }

func_arg  =  { var_name ~ ":" ~ var_type }
func_args = _{ func_arg ~ ("," ~ func_arg)* }
func_def  =  {
    keyword_public? ~ keyword_function ~ func_name ~ "(" ~ func_args? ~ ")" ~ func_return_type? ~ func_body
}

func_call_compiler = { symbol_compile_time }
func_call_args     = { expression ~ (symbol_term_seperator ~ expression)* }
func_call          = { func_call_compiler? ~ var_name ~ symbol_parant_start ~ func_call_args? ~ symbol_parant_end }